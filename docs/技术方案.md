# AutoX 技术方案设计

## 1. 项目概述
AutoX 是一款专为 Windows 平台打造的基于 YOLOv8 的自动化工具，致力于提供极致的识别性能、高仿真的行为模拟以及全流程的数据集处理能力。本项目立足于 Windows 环境，通过深度集成系统底层 API 确保工具的高效与稳定。程序设计目标为**完全自包含**，用户端无需安装任何额外环境或工具。

## 2. 技术栈选型
| 模块 | 推荐技术 | 说明 |
| :--- | :--- | :--- |
| **部署形态** | **完全自包含可执行文件** | 封装所有运行时（Python、CUDA、TensorRT DLLs），用户即开即用。 |
| **开发语言** | Python 3.11.9 | 核心开发版本，追求极致执行效率与库兼容性。 |
| **UI 框架** | PySide6 (Qt) | 提供丰富的 Windows 原生控件支持，性能卓越。 |
| **推理引擎** | PyTorch (CUDA) | 使用 PyTorch 原生推理，确保最佳的兼容性与易用性，支持用户自定义模型直接加载。 |
| **推理加速** | FP16 半精度 | 通过半精度浮点数加速，在不损失精度的前提下提升 NVIDIA 显卡推理速度。 |
| **图像采集** | Windows Desktop Duplication API (DDA) | 高性能屏幕采集，低延迟。采用抽象接口设计，便于未来扩展 WGC 等方案。 |
| **行为模拟** | Win32 API / DD Driver | 支持双模式切换：高性能 DD 驱动 (内核级) 或 Win32 API (SendInput, 用户级)。 |
| **安全防护** | PyArmor + VMProtect | 针对 Windows 环境的专业加壳与混淆方案。 |

## 3. 核心架构设计

### 3.1 模块化分层
- **UI 层**：基于 PySide6，集成 Windows 原生风格界面，负责配置、状态展示、标注及训练。
- **控制层 (Controller)**：核心调度器，利用多线程优化 Windows 下的图像流处理。
- **算法层 (AI Engine)**：基于 PyTorch 推理引擎，利用 CUDA 环境实现高效的图像识别。
- **采集层 (Capture)**：基于 `AbstractCapture` 基类，首选实现为 DDA 接口，确保显存数据高效获取。
- **驱动层 (Driver)**：基于 `AbstractInput` 基类，首选实现为基于 `SendInput` 的 Win32 模拟，预留驱动级扩展。

### 3.2 性能与扩展性策略
- **接口抽象化**：采集和输入模拟均通过抽象基类定义，确保在 DDA 或 SendInput 方案遇到瓶颈时，能以最小代价切换至 WGC 或 驱动级模拟。
- **异步处理**：利用 `QThread` 或 `concurrent.futures` 实现采集、推理、模拟的并行化。

## 4. 关键功能实现方案

### 4.1 模拟人类操作算法
- **鼠标曲线移动**：使用 **Bezier 曲线** 或 **Hypothetical 移动模型**，动态计算每一帧的移动步长。
- **抖动与偏移**：在目标位置引入正态分布的随机偏移（Random Offset），并在移动过程中加入微小抖动。
- **点击间隔**：模拟按下（Down）与弹起（Up）之间的时间差（通常为 50ms-150ms）。

### 4.2 数据集与模型训练
- **标注工具**：集成轻量级标注功能，支持 YOLO 格式导出。
- **训练集成**：封装 `ultralytics` 训练接口，支持在本地一键启动模型训练。

### 4.3 安全与密钥机制
- **离线授权 (一机一码)**：
    - **硬件指纹绑定**：采集 CPU、主板及硬盘序列号生成唯一 Machine ID，密钥与硬件深度绑定。
    - **离线激活**：通过私有算号器生成基于 Machine ID 和有效期的加密密钥，实现 100% 离线验证。
- **时间校验与防篡改**：
    - **本地时间日志**：在系统多个隐蔽位置记录加密的运行时间日志，防止用户通过修改系统时间绕过授权。
    - **防回滚机制**：启动时校验系统时间与历史记录，若系统时间早于最后运行记录，则锁定程序。
- **多层加密加固**：
    - **源码混淆**：使用 PyArmor 进行字节码加密与混淆。
    - **机器码编译**：使用 Nuitka 将 Python 转换为 C++ 并编译为二进制，提升逆向门槛。
    - **商业加壳**：使用 VMProtect 对最终可执行文件进行加壳，实现代码虚拟化与抗调试。

### 4.4 Direct Syscall 输入方案
- **核心原理**：绕过 `user32.dll` 的 `SendInput` 函数，直接通过汇编指令 `syscall` 调用 Windows 内核函数 `NtUserSendInput`。此举能有效规避反作弊系统对 Win32 API 的 Hook 或监控。
- **实现细节**：
    - **汇编层**：在 `syscall_stubs.asm` 中实现 x64 调用约定，将参数正确映射到 `r10`, `rdx`, `r8` 寄存器，并执行 `syscall` 指令。
    - **C 扩展层**：编写 `syscall_module.c` 封装汇编函数，并提供 `send_input` 和 `set_ssn` 的 Python 接口。
    - **动态探测**：在 Python 层实现 `_detect_ssn` 逻辑，通过解析 `win32u.dll` 的导出表和机器码，自动获取当前 Windows 版本的 `NtUserSendInput` 系统调用号（SSN），确保跨版本兼容性。
- **仿真算法**：
    - **高频采样**：以 60Hz 频率下发位移指令，确保 3D 游戏画面的流畅性。
    - **非线性插值**：支持 Cos S-Curve 和 Bézier 曲线平滑移动，模拟真实人类手部动作轨迹。
    - **噪声注入**：在移动步长中加入随机抖动（Jitter），规避行为分析检测。

## 5. 开发路线图 (Roadmap)
1. **Phase 1**: 环境配置与基础框架搭建（UI 主界面 + 配置文件系统）。
2. **Phase 2**: 实现高性能屏幕截图与 YOLOv8 PyTorch 推理集成。
3. **Phase 3**: 开发人类行为模拟驱动算法（曲线鼠标、模拟点击）。
4. **Phase 4**: 实现数据集标注与训练功能。
5. **Phase 5**: 安全加固、密钥系统开发与最终打包。

## 6. 开发步骤 (最佳实践)

### 第一阶段：基础设施与图像采集 (已完成)
- [x] **环境隔离**：使用 Miniconda 创建 Python 3.10.11 隔离环境。
- [x] **目录解耦**：建立模块化目录结构，分离 `capture`, `inference`, `input` 等核心功能。
- [x] **采集抽象化**：实现 `AbstractCapture` 基类，确保系统不强耦合于单一采集方案。
- [x] **高性能 DDA**：集成 `dxcam` 实现 DXGI 采集，并保留 `mss` 作为兼容性回退。

### 第二阶段：AI 推理引擎 (已完成)
- [x] **模型热加载**：封装 YOLOv8 推理类，支持 `.pt` 格式原生加载.
- [x] **源码集成**：将 `ultralytics` 以源码形式集成至项目，支持深度定制.
- [x] **推理加速优化**：启用 FP16 半精度推理，并在 GPU 模式下实现自动显存优化.
- [x] **多目标处理**：实现目标过滤与优先级排序算法（如：距离中心点最近优先）.

### 第三阶段：人类行为模拟 (已完成)
- [x] **输入抽象化**：实现 `AbstractInput` 基类，首选 Win32 `SendInput`.
- [x] **非线性移动算法**：实现基于步进插值与随机噪声的鼠标移动，模拟人类手部肌肉的加速与减速过程.
- [x] **随机性注入**：在点击延迟、移动轨迹中加入高斯分布随机量，规避特征检测.

### 第四阶段：安全防护与授权
- [x] **硬件指纹提取**：编写工具类获取 CPU 序列号、主板 UUID 和硬盘特征，生成 Machine ID.
- [x] **离线算号器**：设计基于 AES 加密的离线授权算法，包含有效期验证.
- [ ] **防调试与防回滚**：集成系统时间校验日志，增加基础的反调试（Anti-Debug）代码.

### 第五阶段：UI 界面与系统集成 (已完成)
- [x] **多线程架构**：使用 `QThread` 将采集、推理、模拟分为独立线程，通过线程安全队列通信.
- [x] **配置管理**：实现配置文件的读写，支持在 UI 上动态调整参数（如：识别灵敏度、平滑度、FOV 范围）.
- [x] **数据集工具**：集成视频抽帧工具，支持按张数或时间间隔自动提取训练素材.

### 第六阶段：最终打包与分发 (核心挑战)
- [ ] **自包含封装**：将 Python 解释器、CUDA 运行库全部打包入分发目录。
- [ ] **多层加固流程**：
    1.  **PyArmor** 混淆核心逻辑。
    2.  **Nuitka** 将 Python 编译为 C++ 二进制。
    3.  **VMProtect** 对最终 `.exe` 进行虚拟化加壳。

## 7. 性能瓶颈分析与优化方向

### 7.1 采集与推理的频率瓶颈 (Frame Freshness) - [已完成]
- **现状**：已将采集频率提升至 60 FPS，并优化了 `controller.py` 的采集循环逻辑。
- **瓶颈**：高频采集对 CPU/GPU 负载有一定增加，需关注中低端机器的稳定性。
- **优化成果**：
    - `DDACapture` 的 `target_fps` 已设为 60。
    - 移除了采集线程的硬性 `sleep`，采用“最新帧覆盖”策略，推理延迟降低，画面鲜活度提升。

### 7.2 显存搬运与零拷贝优化 (Data Transfer Overhead) - [已完成]
- **现状**：已实现端到端 GPU 流程。
- **优化成果**：
    - 利用 `dxcam` 的 GPU 显存映射功能，结合 `CUDA-D3D11 Interop` 技术，实现了图像数据在显存中的直接交换。
    - 推理引擎直接接收 `torch.Tensor` (GPU)，消除了“显存 -> CPU 内存 -> 显存”的两次 PCIe 总线搬运，延迟降低约 5-10ms。
    - **鲁棒性支持**：内置自动降级机制，在跨显卡（如 AMD + NVIDIA）等不支持零拷贝的环境下，自动回退至 CPU 采集，确保系统稳定性。

### 7.3 输入子进程的响应限制 (Input Latency) - [已完成]
- **现状**：`dd_process.py` 中设置了 `min_action_interval = 0.010` (10ms)。
- **优化成果**：
    - 引入指令合并逻辑，在排队时将多个连续位移指令合并为一个高效位移，有效解决了高频微小位移导致的指令堆积问题。
    - 结合带超时的阻塞式获取，在满足 10ms 硬件间隔保护的同时，实现了极低的 CPU 占用。

### 7.4 推理逻辑的阻塞同步 (Inference Blocking) - [已完成]
- **现状**：已移除 `yolo_inference.py` 中的强制同步操作。
- **优化成果**：
    - 移除了推理前的 `torch.cuda.synchronize()` 调用，允许 CPU 准备后续数据与 GPU 执行推理并行，显著提升了流水线吞吐量。
    - **未来计划**：在确保显卡兼容性的前提下，探索 FP16（半精度）推理以进一步压榨性能。

### 7.5 局部推理与预处理加速 (Preprocessing) - [已完成]
- **现状**：图像预处理（缩放、归一化）已完全移至 GPU 执。
- **优化成果**：
    - 利用 CUDA 核心实现瞬时预处理，不再依赖 CPU 进行图像格式转换和裁剪。

### 7.6 目标跟踪稳定性优化 (Tracking Stability) - [已完成]
- **现状**：在目标特征不明显或被遮挡时，检测结果易出现高频断续，导致画面（镜头）抽动。
- **优化成果**：
    - **预测保持机制 (Prediction Persistence)**：引入卡尔曼滤波轨迹预测。当目标短时间消失时（< 10帧），系统根据历史运动惯性继续输出预测坐标，平滑桥接检测间隙。
    - **置信度滞后逻辑 (Confidence Hysteresis)**：采用动态双阈值策略。初始锁定需高置信度（0.4），一旦锁定后，允许目标在较低置信度（0.3）下维持吸附，减少边缘状态下的频繁脱锁。
    - **多重平滑滤波**：默认开启卡尔曼滤波与 EMA（指数移动平均）双重滤波，将 EMA 因子优化为 0.5，显著过滤了检测框中心点的微小抖动。

---
*本文档将根据开发进度持续更新。*



